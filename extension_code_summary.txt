VS Code Extension Code Summary - Generated 2024-11-16 16:30:00



=== File: C:\Users\rober\Documents\GitHub\claude-vscode\CHANGELOG.md ===

# Changelog

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [1.1.0] - 2024-11-13
### Added
- Secure API key management ðŸ”
- Environment variable support for API key
- Enhanced security documentation
- VS Code secure storage integration

### Changed
- Updated authentication flow to use API keys
- Improved error handling for authentication issues
- Enhanced README with security best practices
- Optimized marketplace documentation formatting

### Security
- Implemented secure API key storage
- Added authentication validation
- Enhanced privacy measures
- Added comprehensive security documentation

## [1.0.0] - 2024-03-12
### Official Stable Release! ðŸŽ‰
- Everything you need, nothing you don't
- Stable, tested, and ready for daily use
- Full support for Claude 3 models

### Features
- Direct Claude integration in VS Code
- Code documentation generation
- Smart context handling
- Clean Markdown responses
- Progress indicators
- Token usage tracking
- Model selection (Opus/Sonnet)

## [0.1.1] - 2024-03-12
### Added
- Model selection in settings (claude-3-opus-20240229 or claude-3-sonnet-20240229)
- Progress indicator in status bar during requests
- Token usage display in responses
- Proper error handling with user-friendly messages

### Changed
- Improved response formatting with Markdown
- Optimized package size and performance
- Updated to latest Claude API version
- Better error messages for common issues

### Fixed
- Package structure and duplicate assets
- Build process optimizations
- Extension activation events

## [0.1.0] - 2024-03-12
### Added
- Initial release
- Two main commands: "Ask Claude" and "Document Code"
- Basic integration with Claude API
- Support for text selection and code documentation
- Markdown-formatted responses
- Side-by-side response view
- Basic configuration options

[1.1.0]: https://github.com/conscious-robot/claude-vscode/compare/v1.0.0...v1.1.0
[1.0.0]: https://github.com/conscious-robot/claude-vscode/compare/v0.1.1...v1.0.0
[0.1.1]: https://github.com/conscious-robot/claude-vscode/compare/v0.1.0...v0.1.1
[0.1.0]: https://github.com/conscious-robot/claude-vscode/releases/tag/v0.1.0




=== File: C:\Users\rober\Documents\GitHub\claude-vscode\esbuild.js ===

const esbuild = require("esbuild");

const production = process.argv.includes("--production");
const watch = process.argv.includes("--watch");

const esbuildProblemMatcherPlugin = {
    name: "esbuild-problem-matcher",
    setup(build) {
        build.onStart(() => {
            console.log("[watch] build started");
        });
        build.onEnd((result) => {
            if (result.errors.length > 0) {
                result.errors.forEach(({ text, location }) => {
                    console.error(`âœ˜ [ERROR] ${text}`);
                    console.error(
                        `    ${location.file}:${location.line}:${location.column}:`,
                    );
                });
            }
            console.log("[watch] build finished");
        });
    },
};

/** @type {import('esbuild').BuildOptions} */
const buildOptions = {
    entryPoints: ["src/extension.ts"],
    bundle: true,
    format: "cjs",
    minify: production,
    sourcemap: !production,
    sourcesContent: false,
    platform: "node",
    outfile: "dist/extension.js",
    external: ["vscode"],
    logLevel: "info",
    plugins: [esbuildProblemMatcherPlugin],
};

async function build() {
    try {
        if (watch) {
            const ctx = await esbuild.context(buildOptions);
            await ctx.watch();
            console.log("Watching...");
        } else {
            await esbuild.build(buildOptions);
        }
    } catch (err) {
        console.error("Build failed:", err);
        process.exit(1);
    }
}

build();




=== File: C:\Users\rober\Documents\GitHub\claude-vscode\eslint.config.js ===

// eslint.config.js
import eslint from '@eslint/js';
import tseslint from '@typescript-eslint/eslint-plugin';
import tsparser from '@typescript-eslint/parser';
import globals from 'globals';

export default [
    {
        ignores: [
            'out/**',
            'dist/**',
            'node_modules/**',
            '.vscode-test/**',
            'examples/**',
            'deno/**'
        ]
    },
    {
        files: ['src/**/*.ts', 'test/**/*.ts'],
        languageOptions: {
            parser: tsparser,
            parserOptions: {
                ecmaVersion: 2020,
                sourceType: 'module',
                project: ['./tsconfig.json', './tsconfig.test.json']
            },
            globals: {
                ...globals.node,
                ...globals.mocha
            }
        },
        plugins: {
            '@typescript-eslint': tseslint
        },
        rules: {
            ...eslint.configs.recommended.rules,
            ...tseslint.configs.recommended.rules,
            '@typescript-eslint/naming-convention': [
                'error',
                {
                    selector: 'default',
                    format: ['camelCase']
                },
                {
                    selector: 'variable',
                    format: ['camelCase', 'UPPER_CASE']
                },
                {
                    selector: 'parameter',
                    format: ['camelCase'],
                    leadingUnderscore: 'allow'
                },
                {
                    selector: 'memberLike',
                    modifiers: ['private'],
                    format: ['camelCase'],
                    leadingUnderscore: 'require'
                },
                {
                    selector: 'typeLike',
                    format: ['PascalCase']
                }
            ],
            '@typescript-eslint/semi': 'warn',
            'curly': 'warn',
            'eqeqeq': 'warn',
            'no-throw-literal': 'warn',
            'semi': 'off'
        }
    }
];




=== File: C:\Users\rober\Documents\GitHub\claude-vscode\package.json ===

{
  "name": "claude-vscode-assistant",
  "displayName": "Claude AI Assistant",
  "version": "1.1.1",
  "description": "Claude AI assistant for Visual Studio Code",
  "publisher": "conscious-robot",
  "repository": {
    "type": "git",
    "url": "https://github.com/talamantez/claude-vscode"
  },
  "engines": {
    "vscode": "^1.95.0"
  },
  "categories": [
    "Machine Learning",
    "Programming Languages",
    "Other"
  ],
  "keywords": [
    "claude",
    "ai",
    "assistant",
    "anthropic",
    "code"
  ],
  "activationEvents": [
    "onCommand:claude-vscode.askClaude",
    "onCommand:claude-vscode.documentCode"
  ],
  "main": "./dist/extension.js",
  "icon": "logo.png",
  "contributes": {
    "commands": [
      {
        "command": "claude-vscode.askClaude",
        "title": "Ask Claude",
        "icon": "$(comment-discussion)"
      },
      {
        "command": "claude-vscode.documentCode",
        "title": "Document Code with Claude",
        "icon": "$(book)"
      },
      {
        "command": "claude-vscode.support",
        "title": "Support Open Source ðŸ¥“",
        "category": "Claude AI"
      }
    ],
    "menus": {
      "editor/context": [
        {
          "submenu": "claude.menu",
          "group": "navigation"
        }
      ],
      "claude.menu": [
        {
          "command": "claude-vscode.askClaude",
          "group": "claude@1"
        },
        {
          "command": "claude-vscode.documentCode",
          "group": "claude@2"
        },
        {
          "command": "claude-vscode.support",
          "group": "Claude AI"
        }
      ]
    },
    "submenus": [
      {
        "id": "claude.menu",
        "label": "Claude AI"
      }
    ],
    "configuration": {
      "title": "Claude VS Code",
      "properties": {
        "claude-vscode.model": {
          "type": "string",
          "default": "claude-3-opus-20240229",
          "description": "Claude model to use for requests"
        },
        "claude-vscode.apiKey": {
          "type": "string",
          "default": "",
          "description": "Your Claude API Key"
        }
      }
    }
  },
  "scripts": {
    "vscode:prepublish": "pnpm run verify",
    "build": "tsc -p ./tsconfig.json && esbuild src/extension.ts --bundle --outfile=dist/extension.js --external:vscode --format=cjs --platform=node --minify",
    "watch": "node esbuild.js --watch",
    "package": "pnpm run verify && vsce package",
    "publish": "pnpm run verify && vsce publish",
    "verify": "pnpm run build && pnpm run test",
    "pretest": "pnpm run build && pnpm run compile-tests",
    "test": "node --force-node-api-uncaught-exceptions-policy=true ./out/test/runTest.js",
    "compile-tests": "tsc -p ./tsconfig.test.json",
    "watch-tests": "tsc -p ./tsconfig.test.json --watch"
  },
  "devDependencies": {
    "@types/glob": "^8.1.0",
    "@types/mocha": "^10.0.9",
    "@types/node": "^20.0.0",
    "@types/sinon": "^17.0.3",
    "@types/vscode": "^1.95.0",
    "@typescript-eslint/eslint-plugin": "^7.3.1",
    "@typescript-eslint/parser": "^7.3.1",
    "@vscode/test-electron": "^2.3.9",
    "@vscode/vsce": "^2.24.0",
    "esbuild": "^0.19.0",
    "eslint": "^8.57.0",
    "glob": "^10.3.10",
    "mocha": "^10.8.2",
    "sinon": "^19.0.2",
    "ts-node": "^10.9.2",
    "typescript": "^5.0.0"
  }
}





=== File: C:\Users\rober\Documents\GitHub\claude-vscode\README.md ===

# Right Click? Claude!

Bring the power of Claude directly into your development workflow. This extension allows you to interact with Claude AI without leaving VS Code, helping you write, document, and understand code more effectively.

[Basic usage video](https://www.awesomescreenshot.com/video/33547525?key=8c3b97293ba780ded6ba9d19f9423f35)

[Tip! Include text from previous AI responses (video)](https://www.awesomescreenshot.com/video/33636474?key=d16f8b7ef6b546ae58390f5defccb571)

## Key Features

* Ask Claude: Select any text and right click to get instant AI assistance
* Document Code: Automatically generate documentation for your code
* Context-Aware: Include context by including text from previous responses.
* Markdown Output: Responses are formatted in clean, readable Markdown

## Quick Start

1. Install the extension
2. Set up your Claude API key (see below)
3. Select text and use:
   * `Ask Claude` for general assistance
   * `Document Code` for automatic documentation

That's it! No fuss, no muss.

## API Key Setup

### Get Your Key
1. Sign up for an Anthropic account
2. Navigate to API settings
3. Generate a new API key
4. Keep it secure - never share or commit it

### Add Your Key

Method 1 - VS Code Settings (Recommended):
1. Open Settings (Ctrl/Cmd + ,)
2. Search for "Claude VS Code"
3. Enter your API key
4. VS Code stores it securely

Method 2 - Environment Variable:
* Set CLAUDE_API_KEY in your environment
* Ensure secure variable management

## Security First

* Keys stored in VS Code's secure storage
* HTTPS-only API communication
* No data storage or logging
* Direct Claude API integration
* Your key, your control

## Model Selection

Choose your model in VS Code settings:
* claude-3-opus-20240229 (default)
* claude-3-sonnet-20240229

## Requirements

* VS Code 1.80.0+
* Internet connection
* Claude API key

Need help? Visit our [GitHub repository](https://github.com/talamantez/claude-vscode)





=== File: C:\Users\rober\Documents\GitHub\claude-vscode\tsconfig.json ===

{
    "compilerOptions": {
      "module": "commonjs",
      "target": "ES2020",
      "outDir": "dist",
      "rootDir": "src",
      "sourceMap": true,
      "strict": true,
      "noImplicitAny": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "resolveJsonModule": true,
      "lib": ["ES2020"],
      "baseUrl": "."
    },
    "include": [
      "src/**/*"
    ],
    "exclude": [
      "node_modules",
      "examples",
      "deno",
      ".vscode-test",
      "dist"
    ]
  }




=== File: C:\Users\rober\Documents\GitHub\claude-vscode\tsconfig.test.json ===

{
    "extends": "./tsconfig.json",
    "compilerOptions": {
      "rootDir": ".",
      "outDir": "out",
      "types": ["mocha", "node"]
    },
    "include": [
      "src/**/*",
      "test/**/*"
    ]
  }




=== File: C:\Users\rober\Documents\GitHub\claude-vscode\deno\deno.deploy.json ===

{
    "project": "claude-vscode-api",
    "entrypoint": "main.ts",
    "exclude": [".env", "node_modules", ".vscode"]
  }




=== File: C:\Users\rober\Documents\GitHub\claude-vscode\deno\deno.json ===

{
  "tasks": {
    "dev": "deno run --allow-net --allow-env --allow-read --watch main.ts",
    "deploy": "deployctl deploy --project=long-ferret-58 main.ts",
    "start": "deno run --allow-net --allow-env --allow-read main.ts"
  },
  "imports": {
    "vscode": "npm:@types/vscode",
    "node-fetch": "npm:node-fetch@2.7.0",
     "std/": "https://deno.land/std@0.220.1/"
  },
  "compilerOptions": {
    "lib": [
      "deno.window",
      "dom"
    ]
  },
  "deploy": {
    "project": "cad004b4-847a-4c28-8ec4-d81b110916e4",
    "exclude": [
      "**/node_modules",
      "**/node_modules",
      "**/node_modules"
    ],
    "include": [],
    "entrypoint": "main.ts"
  }
}




=== File: C:\Users\rober\Documents\GitHub\claude-vscode\deno\main.js ===

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// deno/main.ts
const server_ts_1 = require("https://deno.land/std@0.220.1/http/server.ts");
// Use Deno KV to track requests
const kv = await Deno.openKv();
const REQUESTS_PER_IP = 25; // Free requests per IP per day
const MS_PER_DAY = 24 * 60 * 60 * 1000;
async function getRequestCount(ip) {
    const key = ["requests", ip];
    const entry = await kv.get(key);
    if (!entry.value) {
        return { count: 0, lastReset: Date.now() };
    }
    // Reset count if it's been more than a day
    if (Date.now() - entry.value.lastReset > MS_PER_DAY) {
        return { count: 0, lastReset: Date.now() };
    }
    return entry.value;
}
async function incrementRequestCount(ip) {
    const key = ["requests", ip];
    const count = await getRequestCount(ip);
    const newCount = {
        count: count.count + 1,
        lastReset: count.lastReset
    };
    await kv.set(key, newCount);
    return REQUESTS_PER_IP - newCount.count;
}
async function askClaude(text, ip) {
    try {
        // Check remaining requests
        const count = await getRequestCount(ip);
        if (count.count >= REQUESTS_PER_IP) {
            const timeUntilReset = (count.lastReset + MS_PER_DAY) - Date.now();
            return new Response(JSON.stringify({
                error: 'RATE_LIMIT_EXCEEDED',
                resetIn: Math.ceil(timeUntilReset / (60 * 1000)), // minutes
                message: `Free tier limit reached. Resets in ${Math.ceil(timeUntilReset / (60 * 1000))} minutes.`
            }), {
                status: 429,
                headers: {
                    "Content-Type": "application/json",
                    "Access-Control-Allow-Origin": "*",
                }
            });
        }
        const response = await fetch("https://api.anthropic.com/v1/messages", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "x-api-key": Deno.env.get("CLAUDE_API_KEY"),
                "anthropic-version": "2023-06-01",
            },
            body: JSON.stringify({
                messages: [{
                        role: "user",
                        content: text,
                    }],
                model: "claude-3-opus-20240229",
                max_tokens: 1024,
            }),
        });
        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }
        const claudeResponse = await response.json();
        const remaining = await incrementRequestCount(ip);
        return new Response(JSON.stringify({
            ...claudeResponse,
            remaining,
            dailyLimit: REQUESTS_PER_IP
        }), {
            headers: {
                "Content-Type": "application/json",
                "Access-Control-Allow-Origin": "*",
            },
        });
    }
    catch (error) {
        return new Response(JSON.stringify({ error: error.message }), {
            status: 500,
            headers: {
                "Content-Type": "application/json",
                "Access-Control-Allow-Origin": "*",
            },
        });
    }
}
const handler = async (request) => {
    // Add health check endpoint
    if (request.method === "GET" && new URL(request.url).pathname === "/health") {
        return new Response(JSON.stringify({
            status: "healthy",
            version: "1.0.0",
            timestamp: new Date().toISOString()
        }), {
            headers: {
                "Content-Type": "application/json",
                "Access-Control-Allow-Origin": "*"
            }
        });
    }
    // Get client IP
    const ip = request.headers.get("x-forwarded-for") || "unknown";
    if (request.method === "OPTIONS") {
        return new Response(null, {
            headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Methods": "POST, OPTIONS",
                "Access-Control-Allow-Headers": "Content-Type",
            },
        });
    }
    if (request.method !== "POST") {
        return new Response("Method not allowed", {
            status: 405,
            headers: {
                "Access-Control-Allow-Origin": "*",
            }
        });
    }
    try {
        const { prompt } = await request.json();
        return await askClaude(prompt, ip);
    }
    catch (error) {
        return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: {
                "Content-Type": "application/json",
                "Access-Control-Allow-Origin": "*",
            }
        });
    }
};
console.log("Service starting...");
(0, server_ts_1.serve)(handler, { port: 8000 });
//# sourceMappingURL=main.js.map




=== File: C:\Users\rober\Documents\GitHub\claude-vscode\deno\main.ts ===

// deno/main.ts
import { serve } from "https://deno.land/std@0.220.1/http/server.ts";

interface RequestCount {
  count: number;
  lastReset: number;
}

// Use Deno KV to track requests
const kv = await Deno.openKv();
const REQUESTS_PER_IP = 25; // Free requests per IP per day
const MS_PER_DAY = 24 * 60 * 60 * 1000;

async function getRequestCount(ip: string): Promise<RequestCount> {
  const key = ["requests", ip];
  const entry = await kv.get<RequestCount>(key);
  
  if (!entry.value) {
    return { count: 0, lastReset: Date.now() };
  }

  // Reset count if it's been more than a day
  if (Date.now() - entry.value.lastReset > MS_PER_DAY) {
    return { count: 0, lastReset: Date.now() };
  }

  return entry.value;
}

async function incrementRequestCount(ip: string): Promise<number> {
  const key = ["requests", ip];
  const count = await getRequestCount(ip);
  
  const newCount = {
    count: count.count + 1,
    lastReset: count.lastReset
  };
  
  await kv.set(key, newCount);
  return REQUESTS_PER_IP - newCount.count;
}

async function askClaude(text: string, ip: string): Promise<Response> {
  try {
    // Check remaining requests
    const count = await getRequestCount(ip);
    if (count.count >= REQUESTS_PER_IP) {
      const timeUntilReset = (count.lastReset + MS_PER_DAY) - Date.now();
      return new Response(
        JSON.stringify({ 
          error: 'RATE_LIMIT_EXCEEDED',
          resetIn: Math.ceil(timeUntilReset / (60 * 1000)), // minutes
          message: `Free tier limit reached. Resets in ${Math.ceil(timeUntilReset / (60 * 1000))} minutes.`
        }), 
        { 
          status: 429,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*",
          }
        }
      );
    }

    const response = await fetch("https://api.anthropic.com/v1/messages", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": Deno.env.get("CLAUDE_API_KEY")!,
        "anthropic-version": "2023-06-01",
      },
      body: JSON.stringify({
        messages: [{
          role: "user",
          content: text,
        }],
        model: "claude-3-opus-20240229",
        max_tokens: 1024,
      }),
    });

    if (!response.ok) {
      throw new Error(`API error: ${response.status}`);
    }

    const claudeResponse = await response.json();
    const remaining = await incrementRequestCount(ip);

    return new Response(
      JSON.stringify({ 
        ...claudeResponse,
        remaining,
        dailyLimit: REQUESTS_PER_IP
      }), 
      {
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*",
        },
      }
    );
  } catch (error) {
    return new Response(
      JSON.stringify({ error: error.message }), 
      {
        status: 500,
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*",
        },
      }
    );
  }
}

const handler = async (request: Request): Promise<Response> => {
  // Add health check endpoint
  if (request.method === "GET" && new URL(request.url).pathname === "/health") {
    return new Response(JSON.stringify({
      status: "healthy",
      version: "1.0.0",
      timestamp: new Date().toISOString()
    }), {
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*"
      }
    });
  }

  // Get client IP
  const ip = request.headers.get("x-forwarded-for") || "unknown";

  if (request.method === "OPTIONS") {
    return new Response(null, {
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "POST, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type",
      },
    });
  }

  if (request.method !== "POST") {
    return new Response("Method not allowed", { 
      status: 405,
      headers: {
        "Access-Control-Allow-Origin": "*",
      }
    });
  }

  try {
    const { prompt } = await request.json();
    return await askClaude(prompt, ip);
  } catch (error) {
    return new Response(
      JSON.stringify({ error: error.message }), 
      { 
        status: 400,
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*",
        }
      }
    );
  }
};

console.log("Service starting...");
serve(handler, { port: 8000 });




=== File: C:\Users\rober\Documents\GitHub\claude-vscode\examples\code-reviewer-extension.js ===

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.activate = activate;
// code-reviewer-extension.ts
const vscode = require("vscode");
const claude_vscode_1 = require("claude-vscode");
function activate(context) {
    // Specialized code review command
    let reviewCommand = vscode.commands.registerCommand('claude-review.reviewCode', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor)
            return;
        const text = editor.document.getText(editor.selection);
        const reviewPrompt = `Review this code for:
- Best practices
- Performance issues
- Security concerns
- Edge cases

Code to review:
${text}

Provide specific, actionable feedback.`;
        // Uses your stable Claude connection
        const response = await (0, claude_vscode_1.askClaude)(reviewPrompt);
        // Custom formatting for reviews
        displayReviewResponse(response);
    });
}
function displayReviewResponse(response) {
    // Custom review display with categories
    const issues = sortIntoCategories(response.content);
    // Could use TreeView or custom WebView
}
//# sourceMappingURL=code-reviewer-extension.js.map




=== File: C:\Users\rober\Documents\GitHub\claude-vscode\examples\code-reviewer-extension.ts ===

// code-reviewer-extension.ts
import * as vscode from 'vscode';
import { askClaude } from 'claude-vscode';

export function activate(context: vscode.ExtensionContext) {
  // Specialized code review command
  let reviewCommand = vscode.commands.registerCommand(
    'claude-review.reviewCode',
    async () => {
      const editor = vscode.window.activeTextEditor;
      if (!editor) return;

      const text = editor.document.getText(editor.selection);
      const reviewPrompt = `Review this code for:
- Best practices
- Performance issues
- Security concerns
- Edge cases

Code to review:
${text}

Provide specific, actionable feedback.`;

      // Uses your stable Claude connection
      const response = await askClaude(reviewPrompt);
      // Custom formatting for reviews
      displayReviewResponse(response);
    }
  );
}

function displayReviewResponse(response: any) {
  // Custom review display with categories
  const issues = sortIntoCategories(response.content);
  // Could use TreeView or custom WebView
}




=== File: C:\Users\rober\Documents\GitHub\claude-vscode\examples\react-analyzer-extension.js ===

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.activate = activate;
// react-analyzer-extension.ts
const vscode = require("vscode");
const claude_vscode_1 = require("claude-vscode");
function activate(context) {
    let analyzeCommand = vscode.commands.registerCommand('claude-react.analyzeComponent', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor)
            return;
        const component = editor.document.getText(editor.selection);
        const analysisPrompt = `Analyze this React component:
${component}

Provide:
1. Component structure
2. Prop usage
3. State management
4. Performance considerations
5. Accessibility issues`;
        const response = await (0, claude_vscode_1.askClaude)(analysisPrompt);
        showComponentAnalysis(response);
    });
}
function showComponentAnalysis(response) {
    // Custom WebView with interactive sections
    const panel = vscode.window.createWebviewPanel('reactAnalysis', 'React Analysis', vscode.ViewColumn.Beside, { enableScripts: true });
    panel.webview.html = `
    <html>
      <body>
        <h1>Component Analysis</h1>
        <div class="analysis-sections">
          ${formatAnalysisSections(response)}
        </div>
      </body>
    </html>
  `;
}
//# sourceMappingURL=react-analyzer-extension.js.map




=== File: C:\Users\rober\Documents\GitHub\claude-vscode\examples\react-analyzer-extension.ts ===

// react-analyzer-extension.ts
import * as vscode from 'vscode';
import { askClaude, ClaudeResponse } from 'claude-vscode';

export function activate(context: vscode.ExtensionContext) {
  let analyzeCommand = vscode.commands.registerCommand(
    'claude-react.analyzeComponent',
    async () => {
      const editor = vscode.window.activeTextEditor;
      if (!editor) return;

      const component = editor.document.getText(editor.selection);
      const analysisPrompt = `Analyze this React component:
${component}

Provide:
1. Component structure
2. Prop usage
3. State management
4. Performance considerations
5. Accessibility issues`;

      const response = await askClaude(analysisPrompt);
      showComponentAnalysis(response);
    }
  );
}

function showComponentAnalysis(response: ClaudeResponse) {
  // Custom WebView with interactive sections
  const panel = vscode.window.createWebviewPanel(
    'reactAnalysis',
    'React Analysis',
    vscode.ViewColumn.Beside,
    { enableScripts: true }
  );

  panel.webview.html = `
    <html>
      <body>
        <h1>Component Analysis</h1>
        <div class="analysis-sections">
          ${formatAnalysisSections(response)}
        </div>
      </body>
    </html>
  `;
}




=== File: C:\Users\rober\Documents\GitHub\claude-vscode\examples\test-generator-extension.js ===

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.activate = activate;
// test-generator-extension.ts
const vscode = require("vscode");
const claude_vscode_1 = require("claude-vscode");
function activate(context) {
    let generateTestCommand = vscode.commands.registerCommand('claude-test.generateTests', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor)
            return;
        const code = editor.document.getText(editor.selection);
        const framework = detectTestFramework(editor.document);
        const testPrompt = `Generate comprehensive tests for this code using ${framework}:
${code}

Include:
- Unit tests
- Edge cases
- Mock examples
- Error scenarios`;
        const response = await (0, claude_vscode_1.askClaude)(testPrompt);
        await createTestFile(response, editor.document);
    });
}
function createTestFile(response, sourceDoc) {
    // Creates a new test file next to the source
    const testPath = sourceDoc.uri.path.replace('.ts', '.test.ts');
    // ... create and open test file
}
//# sourceMappingURL=test-generator-extension.js.map




=== File: C:\Users\rober\Documents\GitHub\claude-vscode\examples\test-generator-extension.ts ===

// test-generator-extension.ts
import * as vscode from 'vscode';
import { askClaude } from 'claude-vscode';

export function activate(context: vscode.ExtensionContext) {
  let generateTestCommand = vscode.commands.registerCommand(
    'claude-test.generateTests',
    async () => {
      const editor = vscode.window.activeTextEditor;
      if (!editor) return;

      const code = editor.document.getText(editor.selection);
      const framework = detectTestFramework(editor.document);
      
      const testPrompt = `Generate comprehensive tests for this code using ${framework}:
${code}

Include:
- Unit tests
- Edge cases
- Mock examples
- Error scenarios`;

      const response = await askClaude(testPrompt);
      await createTestFile(response, editor.document);
    }
  );
}

function createTestFile(response: ClaudeResponse, sourceDoc: vscode.TextDocument) {
  // Creates a new test file next to the source
  const testPath = sourceDoc.uri.path.replace('.ts', '.test.ts');
  // ... create and open test file
}




=== File: C:\Users\rober\Documents\GitHub\claude-vscode\src\api.ts ===

// src/api.ts
import * as vscode from 'vscode';
import { getConfiguration } from './config';

export interface ClaudeMessageContent {
    type: string;
    text: string;
}

export interface ClaudeResponse {
    id: string;
    type: string;
    role: string;
    model: string;
    content: ClaudeMessageContent[];
    stop_reason: string | null;
    stop_sequence: string | null;
    usage: {
        input_tokens: number;
        output_tokens: number;
    };
    remaining?: number;
    dailyLimit?: number;
}

const SERVICE_URL = 'https://long-ferret-58.deno.dev';

export async function askClaude(text: string): Promise<ClaudeResponse> {
    const config = getConfiguration();
    
    try {
        const response = await fetch(SERVICE_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ 
                prompt: text,
                model: config.model
            })
        });

        if (!response.ok) {
            const errorData = await response.text();
            throw new Error(`API error: ${response.status} - ${errorData}`);
        }

        const data: unknown = await response.json();
        
        if (!isClaudeResponse(data)) {
            throw new Error('Invalid response format from Claude API');
        }
        
        return data as ClaudeResponse;
    } catch (error) {
        vscode.window.showErrorMessage(`Failed to call Claude: ${error instanceof Error ? error.message : 'Unknown error'}`);
        throw error;
    }
}

// Type guard function
function isClaudeResponse(data: unknown): data is ClaudeResponse {
    const response = data as Partial<ClaudeResponse>;
    return (
        typeof data === 'object' &&
        data !== null &&
        Array.isArray(response.content) &&
        response.content?.every((item: unknown) => 
            typeof item === 'object' &&
            item !== null &&
            'type' in item &&
            'text' in item &&
            typeof (item as ClaudeMessageContent).type === 'string' &&
            typeof (item as ClaudeMessageContent).text === 'string'
        ) &&
        typeof response.model === 'string' &&
        typeof response.usage === 'object' &&
        response.usage !== null &&
        typeof response.usage.input_tokens === 'number' &&
        typeof response.usage.output_tokens === 'number'
    );
}




=== File: C:\Users\rober\Documents\GitHub\claude-vscode\src\config.ts ===

// src/config.ts
import * as vscode from 'vscode';

export interface Configuration {
    model: string;
    apiKey?: string;
}

export function getConfiguration(): Configuration {
    const config = vscode.workspace.getConfiguration('claude-vscode');
    return {
        model: config.get('model') || 'claude-3-opus-20240229',
        apiKey: config.get('apiKey')
    };
}




=== File: C:\Users\rober\Documents\GitHub\claude-vscode\src\extension.ts ===

// src/extension.ts
import * as vscode from 'vscode';
import { ClaudeApiService, DefaultClaudeApiService } from './services/claude-api';
import { ClaudeResponse } from './api';

// Global state management
let registeredCommands: vscode.Disposable[] = [];
const activePanels = new Set<vscode.Disposable>();
let apiService: ClaudeApiService;
let watchdogTimer: NodeJS.Timeout | undefined;
let isDeactivating = false;

// Constants
const WATCHDOG_INTERVAL = 30000; // 30 seconds
const CLEANUP_TIMEOUT = 1000; // 1 second
const STATUS_BAR_PRIORITY = 100;

/**
 * Manages watchdog timer for panel cleanup
 */
class WatchdogManager {
    private static timer: NodeJS.Timeout | undefined;

    static start() {
        this.stop();
        this.timer = setInterval(() => {
            if (isDeactivating) return;
            
            activePanels.forEach(panel => {
                try {
                    if (panel instanceof vscode.Disposable) {
                        panel.dispose();
                    }
                } catch (error) {
                    console.error('Watchdog: Error disposing panel:', error);
                }
                activePanels.delete(panel);
            });
        }, WATCHDOG_INTERVAL);
    }

    static stop() {
        if (this.timer) {
            clearInterval(this.timer);
            this.timer = undefined;
        }
    }
}

/**
 * Formats the response from Claude into a markdown document
 */
function formatResponse(prompt: string, response: ClaudeResponse, mode: 'general' | 'document'): string {
    const now = new Date().toLocaleString();
    const title = mode === 'document' ? 'Code Documentation' : 'Claude Response';
    const promptTitle = mode === 'document' ? 'Original Code' : 'Your Prompt';

    const content = response.content
        ?.map(item => item.text || '')
        .join('\n') || 'No response content';

    return [
        `# ${title} (${now})`,
        '',
        `## ${promptTitle}`,
        '```',
        prompt,
        '```',
        '',
        '## Response',
        content,
        '',
        '---',
        `*Using ${response.model}*`,
        `*Tokens: ${response.usage?.input_tokens} input, ${response.usage?.output_tokens} output*`
    ].join('\n');
}

/**
 * Creates and manages a response panel
 */
async function createResponsePanel(content: string): Promise<vscode.TextEditor | undefined> {
    try {
        const doc = await vscode.workspace.openTextDocument({
            content,
            language: 'markdown'
        });

        const editor = await vscode.window.showTextDocument(doc, {
            preview: true,
            viewColumn: vscode.ViewColumn.Beside
        });

        if (editor) {
            const disposable = new vscode.Disposable(() => {
                try {
                    vscode.commands.executeCommand('workbench.action.closeActiveEditor');
                } catch (error) {
                    console.error('Error closing panel:', error);
                }
            });
            activePanels.add(disposable);
        }

        return editor;
    } catch (error) {
        console.error('Error creating response panel:', error);
        throw error;
    }
}

/**
 * Handles Claude API requests
 */
async function handleClaudeRequest(mode: 'general' | 'document') {
    const editor = vscode.window.activeTextEditor;
    if (!editor) {
        vscode.window.showInformationMessage('No active editor!');
        return;
    }

    const selection = editor.selection;
    const text = editor.document.getText(selection);
    if (!text) {
        vscode.window.showInformationMessage('Please select some text first');
        return;
    }

    const statusBarItem = vscode.window.createStatusBarItem(
        vscode.StatusBarAlignment.Right,
        STATUS_BAR_PRIORITY
    );
    statusBarItem.text = "$(sync~spin) Asking Claude...";
    statusBarItem.show();

    try {
        const prompt = mode === 'document' 
            ? `Please document this code:\n\n${text}`
            : text;

        const response = await vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: mode === 'document' ? 'Generating Documentation...' : 'Asking Claude...',
            cancellable: false
        }, async () => {
            return await apiService.askClaude(prompt);
        });

        const formattedResponse = formatResponse(text, response, mode);
        await createResponsePanel(formattedResponse);
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        vscode.window.showErrorMessage(`Error: ${errorMessage}`);
        console.error('Error handling Claude request:', error);
    } finally {
        statusBarItem.dispose();
    }
}

/**
 * Cleans up all panels and editors
 */
async function cleanupPanelsAndEditors(): Promise<void> {
    try {
        await vscode.commands.executeCommand('workbench.action.closeAllEditors');
        await new Promise(resolve => setTimeout(resolve, CLEANUP_TIMEOUT));

        activePanels.forEach(panel => {
            try {
                panel.dispose();
            } catch (error) {
                console.error('Error disposing panel:', error);
            }
        });
        activePanels.clear();

        vscode.window.tabGroups.all.forEach(group => {
            group.tabs.forEach(tab => {
                try {
                    const input = tab.input;
                    if (input && typeof input === 'object' && 'dispose' in input) {
                        (input as { dispose: () => void }).dispose();
                    }
                } catch (error) {
                    console.error('Error disposing tab:', error);
                }
            });
        });

        await vscode.commands.executeCommand('workbench.action.closeAllEditors');
    } catch (error) {
        console.error('Error during cleanup:', error);
        throw error;
    }
}

/**
 * Activates the extension
 */
export async function activate(context: vscode.ExtensionContext, service?: ClaudeApiService) {
    console.log('Claude extension activating...');
    
    try {
        registeredCommands.forEach(cmd => cmd.dispose());
        registeredCommands = [];
        
        apiService = service || new DefaultClaudeApiService();
        WatchdogManager.start();

        context.subscriptions.push(new vscode.Disposable(WatchdogManager.stop));

        // Support command for donations
        context.subscriptions.push(
            vscode.commands.registerCommand('claude-vscode.support', () => {
                vscode.env.openExternal(vscode.Uri.parse('https://buy.stripe.com/aEUcQc7Cb3VE22I3cc'));
            })
        );
        
        const commands = [
            vscode.commands.registerCommand(
                'claude-vscode.askClaude',
                () => handleClaudeRequest('general')
            ),
            vscode.commands.registerCommand(
                'claude-vscode.documentCode',
                () => handleClaudeRequest('document')
            )
        ];

        registeredCommands.push(...commands);
        context.subscriptions.push(...commands);

        context.subscriptions.push(new vscode.Disposable(() => {
            activePanels.forEach(panel => {
                try {
                    panel.dispose();
                } catch (error) {
                    console.error('Error disposing panel:', error);
                }
            });
            activePanels.clear();
        }));

        console.log('Claude extension activated');
    } catch (error) {
        console.error('Error during activation:', error);
        throw error;
    }
}

/**
 * Deactivates the extension
 */
export async function deactivate() {
    console.log('Claude extension deactivating...');
    isDeactivating = true;

    try {
        WatchdogManager.stop();
        
        registeredCommands.forEach(cmd => cmd.dispose());
        registeredCommands = [];

        await cleanupPanelsAndEditors();

        console.log('Claude extension deactivated');
    } catch (error) {
        console.error('Error during deactivation:', error);
        throw error;
    } finally {
        isDeactivating = false;
    }
}




=== File: C:\Users\rober\Documents\GitHub\claude-vscode\src\services\claude-api.ts ===

// src/services/claude-api.ts
import * as vscode from 'vscode';
import { askClaude as apiAskClaude, ClaudeResponse } from '../api';

export interface ClaudeApiService {
    askClaude(text: string): Promise<ClaudeResponse>;
}

export class DefaultClaudeApiService implements ClaudeApiService {
    private readonly _disposables: vscode.Disposable[] = [];

    constructor() {
        // Add any initialization if needed
    }

    async askClaude(text: string): Promise<ClaudeResponse> {
        try {
            return await apiAskClaude(text);
        } catch (error) {
            console.error('Error in DefaultClaudeApiService:', error);
            throw error;
        }
    }

    dispose(): void {
        while (this._disposables.length) {
            const disposable = this._disposables.pop();
            if (disposable) {
                try {
                    disposable.dispose();
                } catch (error) {
                    console.error('Error disposing service:', error);
                }
            }
        }
    }
}




=== File: C:\Users\rober\Documents\GitHub\claude-vscode\test\runTest.ts ===

// test/runTest.ts
import * as path from 'path';
import { runTests } from '@vscode/test-electron';

async function main() {
    try {
        // The folder containing the Extension Manifest package.json
        const extensionDevelopmentPath = path.resolve(__dirname, '../../');

        // The path to the extension test script
        const extensionTestsPath = path.resolve(__dirname, './suite/index');

        // Download VS Code, unzip it and run the integration test
        await runTests({
            extensionDevelopmentPath,
            extensionTestsPath,
            launchArgs: [
                '--disable-extensions', // Prevent interference from other extensions
                '--disable-gpu'        // Reduce GPU-related issues that could lead to BSOD
            ]
        });
    } catch (err) {
        console.error('Failed to run tests:', err);
        process.exit(1);
    }
}

main();




=== File: C:\Users\rober\Documents\GitHub\claude-vscode\test\suite\extension.test.ts ===

import * as assert from 'assert';
import * as vscode from 'vscode';
import * as sinon from 'sinon';
import * as path from 'path';
import * as extension from '../../src/extension';
import { ClaudeResponse } from '../../src/api';

async function ensureCommandNotRegistered(commandId: string): Promise<void> {
    const commands = await vscode.commands.getCommands();
    if (commands.includes(commandId)) {
        // Force command context to be cleared
        await vscode.commands.executeCommand('setContext', 'claude-vscode.commandsRegistered', false);
        // Wait for VS Code to process the context change
        await new Promise(resolve => setTimeout(resolve, 1000));
    }
}

// Mock Environment Variable Collection Class
class MockEnvironmentVariableCollection implements vscode.GlobalEnvironmentVariableCollection {
    private _map = new Map<string, vscode.EnvironmentVariableMutator>();

    public persistent = false;
    public description: string | vscode.MarkdownString = 'Test Environment Variables';

    getScoped(scope: vscode.EnvironmentVariableScope): vscode.EnvironmentVariableCollection {
        return this;
    }

    replace(variable: string, value: string): void {
        this._map.set(variable, {
            value,
            type: vscode.EnvironmentVariableMutatorType.Replace,
            options: { applyAtProcessCreation: true }
        });
    }

    append(variable: string, value: string): void {
        this._map.set(variable, {
            value,
            type: vscode.EnvironmentVariableMutatorType.Append,
            options: { applyAtProcessCreation: true }
        });
    }

    prepend(variable: string, value: string): void {
        this._map.set(variable, {
            value,
            type: vscode.EnvironmentVariableMutatorType.Prepend,
            options: { applyAtProcessCreation: true }
        });
    }

    get(variable: string): vscode.EnvironmentVariableMutator | undefined {
        return this._map.get(variable);
    }

    forEach(callback: (variable: string, mutator: vscode.EnvironmentVariableMutator, collection: vscode.EnvironmentVariableCollection) => void): void {
        const self = this as vscode.EnvironmentVariableCollection;
        this._map.forEach((mutator, variable) => callback(variable, mutator, self));
    }

    delete(variable: string): void {
        this._map.delete(variable);
    }

    clear(): void {
        this._map.clear();
    }

    [Symbol.iterator](): Iterator<[string, vscode.EnvironmentVariableMutator]> {
        return this._map.entries();
    }
}

// Helper function to wait for condition with timeout
async function waitForCondition(condition: () => boolean, timeout: number = 10000, interval: number = 100): Promise<boolean> {
    const startTime = Date.now();
    while (Date.now() - startTime < timeout) {
        if (condition()) {
            return true;
        }
        await new Promise(resolve => setTimeout(resolve, interval));
    }
    return false;
}

// Helper to ensure all editors are closed
async function ensureNoEditors(maxAttempts: number = 5): Promise<void> {
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
        if (vscode.window.visibleTextEditors.length === 0) {
            return;
        }
        await vscode.commands.executeCommand('workbench.action.closeAllEditors');
        await new Promise(resolve => setTimeout(resolve, 500));
    }
    throw new Error('Failed to close all editors');
}

function createMockExtensionContext(): vscode.ExtensionContext {
    const baseDir = path.join(__dirname, '../../');
    const context: vscode.ExtensionContext = {
      subscriptions: [],
      extensionUri: vscode.Uri.file(baseDir),
      extensionPath: baseDir,
      globalState: {
        get: (key: string) => Promise.resolve(undefined),
        update: (key: string, value: any) => Promise.resolve(),
        keys: () => [],
        setKeysForSync: (keys: readonly string[]) => {}
      },
      workspaceState: {
        get: (key: string) => Promise.resolve(undefined),
        update: (key: string, value: any) => Promise.resolve(),
        keys: () => []
      },
      globalStoragePath: path.join(baseDir, 'global-storage'),
      storagePath: path.join(baseDir, 'storage'),
      logPath: path.join(baseDir, 'logs'),
      asAbsolutePath: (relativePath: string) => path.join(baseDir, relativePath),
      storageUri: vscode.Uri.file(path.join(baseDir, 'storage')),
      globalStorageUri: vscode.Uri.file(path.join(baseDir, 'global-storage')),
      logUri: vscode.Uri.file(path.join(baseDir, 'logs')),
      extensionMode: vscode.ExtensionMode.Test,
      environmentVariableCollection: new MockEnvironmentVariableCollection(),
      secrets: {
        get: (key: string) => Promise.resolve(undefined),
        store: (key: string, value: string) => Promise.resolve(),
        delete: (key: string) => Promise.resolve(),
        onDidChange: new vscode.EventEmitter<vscode.SecretStorageChangeEvent>().event
      },
      extension: {
        id: 'test-extension',
        extensionUri: vscode.Uri.file(baseDir),
        extensionPath: baseDir,
        isActive: true,
        packageJSON: {},
        exports: undefined,
        activate: () => Promise.resolve(),
        extensionKind: vscode.ExtensionKind.Workspace
      }
      ,
      languageModelAccessInformation: {
          canSendRequest: function (chat: vscode.LanguageModelChat): boolean | undefined {
              throw new Error('Function not implemented.');
          },
          // @ts-ignore
          onDidChange:  () => {}
      }
    };
  
    return context;
  }

suite('Extension Test Suite', () => {
    let sandbox: sinon.SinonSandbox;

    suiteSetup(async () => {
        console.log('Suite setup starting...');
        const ext = vscode.extensions.getExtension('conscious-robot.claude-vscode-assistant');
        if (ext) {
            console.log('Found extension, activating...');
            await ext.activate();
        } else {
            console.log('Extension not found, activating manually...');
            await extension.activate(createMockExtensionContext());
        }
        console.log('Suite setup complete');

        // Ensure clean state
        await ensureNoEditors();
    });

    setup(async () => {
        sandbox = sinon.createSandbox();
        await ensureNoEditors();
        await ensureCommandNotRegistered('claude-vscode.askClaude');
    });

    teardown(async () => {
        sandbox.restore();
        await ensureNoEditors();
    });

    suiteTeardown(async () => {
        console.log('Suite teardown starting...');
        await ensureNoEditors();
        console.log('Suite teardown complete');
    });

    // Modify the Response Panel test
    test('Response Panel Creation and Disposal', async function () {
        // The test body remains the same as before
    });

    test('Multiple Panel Creation and Cleanup', async function () {
        // The test body remains the same as before
    });

    test('Manual Deactivation Cleanup', async function () {
        // The test body remains the same as before
    });
});




=== File: C:\Users\rober\Documents\GitHub\claude-vscode\test\suite\index.ts ===

// test/suite/index.ts
import * as path from 'path';
import Mocha from 'mocha';
import { glob } from 'glob';

export async function run(): Promise<void> {
    // Create the mocha test
    const mocha = new Mocha({
        ui: 'tdd',
        color: true,
        timeout: 60000
    });

    const testsRoot = path.resolve(__dirname, '.');

    try {
        const files = await glob('**/**.test.js', { cwd: testsRoot });
        
        // Add files to the test suite
        files.forEach((f: string) => mocha.addFile(path.resolve(testsRoot, f)));

        // Run the mocha test
        return new Promise<void>((resolve, reject) => {
            try {
                mocha.run((failures: number) => {
                    if (failures > 0) {
                        reject(new Error(`${failures} tests failed.`));
                    } else {
                        resolve();
                    }
                });
            } catch (err) {
                reject(err);
            }
        });
    } catch (err) {
        throw new Error(`Error loading test files: ${err}`);
    }
}




=== File: C:\Users\rober\Documents\GitHub\claude-vscode\test\suite\resource.test.ts ===

// test/suite/resource.test.ts
import * as assert from 'assert';
import * as vscode from 'vscode';
import * as extension from '../../src/extension';

suite('Resource Management Test Suite', () => {
    test('Multiple Panel Creation and Cleanup', async function() {
        this.timeout(45000);
        console.log('Starting Multiple Panel test...');

        const panelCount = 5;
        const panels: vscode.TextEditor[] = [];  // Properly typed array

        try {
            // Create multiple panels
            for (let i = 0; i < panelCount; i++) {
                console.log(`Creating panel ${i + 1}/${panelCount}`);
                const doc = await vscode.workspace.openTextDocument({
                    content: `Test content ${i + 1}`,
                    language: 'markdown'
                });
                
                const editor = await vscode.window.showTextDocument(doc, {
                    viewColumn: vscode.ViewColumn.Beside
                });
                panels.push(editor);

                // Verify panel was created
                assert.ok(
                    vscode.window.visibleTextEditors.includes(editor),
                    `Panel ${i + 1} should be visible`
                );

                // Wait a bit between creations
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            // Record memory usage
            const initialMemory = process.memoryUsage();

            // Close panels one by one
            for (let i = 0; i < panels.length; i++) {
                console.log(`Closing panel ${i + 1}/${panelCount}`);
                await vscode.commands.executeCommand('workbench.action.closeActiveEditor');
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            // Force garbage collection if possible
            if (global.gc) {
                global.gc();
            }

            // Wait for cleanup
            await new Promise(resolve => setTimeout(resolve, 2000));

            // Check memory usage
            const finalMemory = process.memoryUsage();
            const memoryDiff = finalMemory.heapUsed - initialMemory.heapUsed;
            
            console.log('Memory usage difference:', memoryDiff);
            assert.ok(
                memoryDiff < 5 * 1024 * 1024, // Allow up to 5MB difference
                'Memory usage should not increase significantly'
            );

            // Verify all editors are closed
            assert.strictEqual(
                vscode.window.visibleTextEditors.length,
                0,
                'All editors should be closed'
            );

        } catch (error) {
            console.error('Test failed:', error);
            throw error;
        }
    });

    test('Manual Deactivation Cleanup', async function() {
        this.timeout(30000);
        console.log('Starting Manual Deactivation test...');

        try {
            // Create some test documents
            const docs = await Promise.all([
                vscode.workspace.openTextDocument({
                    content: 'Test content 1',
                    language: 'markdown'
                }),
                vscode.workspace.openTextDocument({
                    content: 'Test content 2',
                    language: 'markdown'
                })
            ]);

            // Show documents
            const editors: vscode.TextEditor[] = [];  // Properly typed array
            for (const doc of docs) {
                const editor = await vscode.window.showTextDocument(doc, { 
                    viewColumn: vscode.ViewColumn.Beside 
                });
                editors.push(editor);
            }

            // Verify editors are open
            assert.ok(
                vscode.window.visibleTextEditors.length > 0,
                'Should have open editors'
            );

            console.log('Calling deactivate function...');
            // Call deactivate function directly
            await extension.deactivate();

            // Wait for cleanup
            await new Promise(resolve => setTimeout(resolve, 2000));

            // Close any remaining editors
            await vscode.commands.executeCommand('workbench.action.closeAllEditors');
            
            // Final wait for cleanup
            await new Promise(resolve => setTimeout(resolve, 1000));

            // Verify cleanup
            assert.strictEqual(
                vscode.window.visibleTextEditors.length,
                0,
                'All editors should be cleaned up after deactivation'
            );

            console.log('Deactivation test completed successfully');
        } catch (error) {
            console.error('Deactivation test failed:', error);
            throw error;
        }
    });
});



